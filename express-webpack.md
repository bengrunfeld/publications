# Creating an Node Express & Webpack Application with Dev and Prod Builds

This is a very long article. I'm sorry - it takes time to explain this stuff.

I **REALLY** struggled with building an error-free Webpack and Express application boilerplate. 

Every time I would pass one hurdle, another error would get generated by the next thing in the heap that was braking. Honestly, it was a very frustrating experience. 

Considering the fact that Express and Webpack are amongst the most used technologies on the web, you'd think that there were a lot more blog posts out there about how to set them up together, but no, you'd be wrong.

There are a couple that look at one aspect or another of integration, but besides [Alejandro Napoles'](https://alejandronapoles.com/) FANTASTIC series on the issue, there's really not much else. 

Link to code: **[Expack](https://github.com/bengrunfeld/expack)** (Express + Webpack). Similarily, the React version is called **[Rexpack](https://github.com/bengrunfeld/rexpack)** (React + Express + Webpack).

If you like the article or this project, please show some love by hitting the Clap/Applause button, starring it on Github (I love stars!!!), or just tweeting me a quick thank you note at [@bengrunfeld](https://twitter.com/bengrunfeld), which I also love.

## What We Want To Make

Firstly, we want to have both a development build of our code, as well as a production build, because we want to employ certain tools in one but not the other. 

For our Development build, we want to transpile it from ES6+, lint it, run unit tests on it, run coverage reports for it, and to enable Hot Module Replacement (HMR) for an easier development experience. Re bundling, we do NOT want to minify it or uglify it, so that we can explore features and find bugs more easily. Similarly, we want the images to stay as their own files so that they are more easily identifiable - as opposed to being encoded in Base64 straight into our CSS file. 

For our Production build, we want the file sizes to be as small as possible to increase app loading speed and usage speed (especially on mobile devices, which may have limited bandwidth). We also want there to be as few files as possible to reduce the number of requests from to the server. With all that in mind, we'll want to minify and uglify our code, with comments and blank space stripped out. We will also want to encode images directly into our CSS files as Base64 to reduce the amount of files (as above).

To avoid unnecessary imports and to keep Dev and Prod concepts clearly seperate, we will have a seperate **Express server file** for Dev and Prod, and seperate **Webpack config files** for Dev and Prod application code, and for the server too.

If you're already confused, please don't worry. It will become clearer as we build out the app. Once you've finished the article, read this section again and it will make more sense.

## Our Tech Stack

These are the main technologies we want to employ:

* Express - server
* Webpack 4 - bundling
* Jest - testing
* Babel - ES6+ transpilation
* ESlint - Linting
* Webpack Dev Middleware - Bundle code in memory instead of in a file
* Webpack Hot Middleware - Enables Hot Module Replacement (HMR)
* UglifyJS - uglifies code
* mini-css-extract-plugin - minifies CSS

NOTE: The next article that deals with building a React Express Webpack application will simply add React to this tech stack, with some special configuration changes. 

## Ok, Let's Begin - Step 1: The Express Server

I'm running all of this on macOS Sierra 10.12.6, with Node v10.0.0, NPM 6.0.0, Webpack 4, Express 4.16.3. 

Let's start from scratch with a new directory. We will test incrementally as we go, so you can identify errors in a specific area as opposed to installing everything and then at the end having no clue where it is.

    mkdir express-webpack
    cd express-webpack

First create a `package.json`.

    npm init -y

Now we can install Express.

    npm install --save express

Add the following to your `package.json`.

    "scripts": {
      "start": "node ./server.js"
    },

Let's write a basic Exress server file in the project root directory, `server.js` to test that it works.

    const path = require('path')
    const express = require('express')
    
    const app = express(),
                DIST_DIR = __dirname,
                HTML_FILE = path.join(DIST_DIR, 'index.html')
    
    
    app.use(express.static(DIST_DIR))
    
    app.get('*', (req, res) => {
        res.sendFile(HTML_FILE)
    })
    
    const PORT = process.env.PORT || 8080
    app.listen(PORT, () => {
        console.log(`App listening to ${PORT}....`)
        console.log('Press Ctrl+C to quit.')
    })

And of course, a nice simple HTML file to say Hello.

    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Express and Webpack App</title>
        <link rel="shortcut icon" href="#">
    </head>
    <body>
        <h1>Expack</h1>
        <p class="description">Express and Webpack Boilerplate App</p>
    </body>
    </html>

Now, to test that it works, run `npm start` and navigate to `http://localhost:8080`. Page should display the HTML correctly.

NOTE: Make sure to open the Console in Chrome Dev Tools to ensure that no Javascript or other errors are being generated.

## Step 2: Install and Enable Webpack

Let's install Webpack (currently at version 4) and configure it. We need the  CLI tools to call it from the command line, and we need `webpack-node-externals` to ignore `node_modules` when creating the build for the server. If we try to build an Express server with `node_modules`, we get hit with a ton of errors. 

    npm install --save-dev webpack webpack-cli webpack-node-externals

And we'll also install Babel to transpile ES6+ to ES5 (what Browsers still need to consume).

    npm install --save-dev babel-core babel-loader babel-preset-env

We're also going to need to install `html-loader` and `html-webpack-plugin` to copy our `index.html` file to the `dist` directory. This plugin will also insert a `script` tag in the HTML file that imports the main Javascript file.

    npm install --save-dev html-loader html-webpack-plugin

Now we must create the Webpack config file - `webpack.config.js`, and it should look like this:

    const path = require('path')
    const webpack = require('webpack')
    const nodeExternals = require('webpack-node-externals')
    const HtmlWebPackPlugin = require("html-webpack-plugin")
    
    module.exports = {
      entry: {
        server: './server.js',
      },
      output: {
        path: path.join(__dirname, 'dist'),
        publicPath: '/',
        filename: '[name].js'
      },
      target: 'node',
      node: {
        // Need this when working with express, otherwise the build fails
        __dirname: false,   // if you don't put this is, __dirname
        __filename: false,  // and __filename return blank or /
      },
      externals: [nodeExternals()], // Need this to avoid error when working with Express
      module: {
        rules: [
          {
            // Transpiles ES6-8 into ES5
            test: /\.js$/,
            exclude: /node_modules/,
            use: {
              loader: "babel-loader"
            }
          },
          {
            // Loads the javacript into html template provided.
            // Entry point is set below in HtmlWebPackPlugin in Plugins 
            test: /\.html$/,
            use: [{loader: "html-loader"}]
          }
        ]
      },
      plugins: [
        new HtmlWebPackPlugin({
          template: "./index.html",
          filename: "./index.html",
          excludeChunks: [ 'server' ]
        })
      ]
    }

Note that `excludeChunks` will exclude a file called `server` which we don't want to be included into our HTML file, since that is the webserver, and not needed in the app itself.

Change `server.js` to have ES6+ `import` syntax instead of Node's `require` to test that Babel transpilation is happening correctly.

    import path from 'path'
    import express from 'express'
    
    const app = express(),
                DIST_DIR = __dirname,
                HTML_FILE = path.join(DIST_DIR, 'index.html')
    
    
    app.use(express.static(DIST_DIR))
    
    app.get('*', (req, res) => {
        res.sendFile(HTML_FILE)
    })
    
    const PORT = process.env.PORT || 8080
    app.listen(PORT, () => {
        console.log(`App listening to ${PORT}....`)
        console.log('Press Ctrl+C to quit.')
    })

Create a file called `.babelrc` in your root and fill it with this code:

    {
      'presets': ['env']
    }

And change `package.json` scripts to the following:

    "scripts": {
      "build": "rm -rf dist && webpack --mode development",
      "start": "node ./dist/server.js"
    },

That way we always start with a fresh `dist` folder, and we declaratively set devlopment mode from the command line. 

Now you can run `npm run build` and `npm start` and navigate to `localhost:8080` to test. At this point, there should be no errors (fingers crossed...). I'm building this step by step as I'm writing this article and the above configuration works for me.

## Step 3: Add CSS and Javascript Functionality to App

We have quite a bit of functionality in place already, but lets add CSS styles, Javascript, and images to our app.

To do this, we are going to need to separate our Webpack config into 2 files, which will later even become 3 files. One will only deal with bundling the server code - `webpack.server.config.js` and the other will deal with bundling the application code - `webpack.config.js`. Later, we'll separate this main config file into Dev and Prod versions, and we'll separate the server file into Dev and Prod versions too.

First, let's install the necessary dependencies:

    npm install --save-dev css-loader file-loader style-loader

Our directory structure should look like this:

    .babelrc
    .git
    .gitignore
    README.md
    dist
    node_modules
    package-lock.json
    package.json
    webpack.config.js
    webpack.server.config.js
    src
        index.js
        html
            index.html
        css
            style.css
        js
            index.js
        img
            awful-selfie.jpg
        server
            server.js

Adjust your `package.json` scripts.

    "scripts": {
      "build": "rm -rf dist && webpack --mode development --config webpack.server.config.js && webpack --mode development",
      "start": "node ./dist/server.js"
    },

Now update `./src/html/index.html`

    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Express and Webpack App</title>
        <link rel="shortcut icon" href="#">
    </head>
    <body>
        <h1>Expack</h1>
        <p class="description">Express and Webpack Boilerplate App</p>
        <div class="awful-selfie"></div>
    </body>
    </html>

Now update `./src/css/style.css`

    h1, h2, h3, h4, h5, p {
      font-family: helvetica;
      color: #3e3e3e;
    }
    
    .description {
      font-size: 14px;
      color: #9e9e9e;
    }
    
    .awful-selfie{
      background: url(../img/bg.jpg);
      width: 300px;
      height: 300px;
      background-size: 100% auto;
      background-repeat: no-repeat;
    }

Now update `./src/index.js` to check that imports and styles are working, as well as some basic functionality.

    import logMessage from './js/logger'
    import './css/style.css'
    
    // Log message to console
    logMessage('Welcome to Expack!')

And of course `./src/js/logger.js`

    const logMessage = msg => console.log(msg)
    
    export default logMessage

Just move `server.js` from the root into `./src/server`. This keeps the root clean and keeps server code in a location that's appropriate.

Finally, let's take care of Webpack config. We'll start with `./webpack.server.config.js`.

    const path = require('path')
    const webpack = require('webpack')
    const nodeExternals = require('webpack-node-externals')
    
    module.exports = {
      entry: {
        server: './src/server/server.js',
      },
      output: {
        path: path.join(__dirname, 'dist'),
        publicPath: '/',
        filename: '[name].js'
      },
      target: 'node',
      node: {
        // Need this when working with express, otherwise the build fails
        __dirname: false,   // if you don't put this is, __dirname
        __filename: false,  // and __filename return blank or /
      },
      externals: [nodeExternals()], // Need this to avoid error when working with Express
      module: {
        rules: [
          {
            // Transpiles ES6-8 into ES5
            test: /\.js$/,
            exclude: /node_modules/,
            use: {
              loader: "babel-loader"
            }
          }
        ]
      }
    }

And now let's finish everything off with `./webpack.config.js`.

    const path = require("path")
    const webpack = require('webpack')
    const HtmlWebPackPlugin = require("html-webpack-plugin")
    
    module.exports = {
      entry: {
        main: './src/index.js'
      },
      output: {
        path: path.join(__dirname, 'dist'),
        publicPath: '/',
        filename: '[name].js'
      },
      target: 'web',
      devtool: '#source-map',
      module: {
        rules: [
          {
            test: /\.js$/,
            exclude: /node_modules/,
            loader: "babel-loader",
          },
          {
            // Loads the javacript into html template provided.
            // Entry point is set below in HtmlWebPackPlugin in Plugins 
            test: /\.html$/,
            use: [
              {
                loader: "html-loader",
                //options: { minimize: true }
              }
            ]
          },
          {
            test: /\.css$/,
            use: [ 'style-loader', 'css-loader' ]
          },
          {
           test: /\.(png|svg|jpg|gif)$/,
           use: ['file-loader']
          }
        ]
      },
      plugins: [
        new HtmlWebPackPlugin({
          template: "./src/html/index.html",
          filename: "./index.html",
          excludeChunks: [ 'server' ]
        })
      ]
    }

If you run `npm run build`, you should not receive any errors. If you do, hunt them down. They 

## Step 4: Seperate App into Dev and Prod Builds


## Step 5: Add Webpack Dev Middleware


## Step 6: Add Hot Module Replacement









